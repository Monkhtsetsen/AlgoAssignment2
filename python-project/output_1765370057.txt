============================================================
ТЕКСТИЙГ ЖИГДЛЭХ ПРОГРАМ - ҮР ДҮН
============================================================

  1: ================================================================================
  2: ХАРЬЦУУЛАЛТЫН                                               ШИНЖИЛГЭЭ:
  3: ================================================================================
  4: ҮЗҮҮЛЭЛТ                           GREEDY                           DP
  5: -------------------------------------------------------         Мөрийн
  6: тоо  19  18  Цаг  (микросекунд)  1,076  1,826 Хурдны харьцаа 1.0x 1.70
  7: x  Нийт  хоосон  зай  94  95  Hyphenation  тоо  0  0 ДҮГНЭЛТ: ✓ Greedy
  8: алгоритм  DP-с  1.7  дахин  хурдан  ✓  DP алгоритм 1 мөрөөр хэмнэлттэй
  9: ================================================================================
 10: АЛГОРИТМЫН              ЗӨВ              БАЙДЛЫН             НОТОЛГОО:
 11: ================================================================================
 12: GREEDY  АЛГОРИТМЫН  LOOP  INVARIANT:  Өмнөх  нөхцөл:  Мөр бүр дээр аль
 13: болох  олон  үг  байрлана.  Loop  Invariant: Алгоритмын давталт бүрийн
 14: дараа:  1.  Үүссэн  мөрүүд  бүрэн  жигдлэгдсэн  байна.  2.  Үг  бүр яг
 15: нэг  удаа  боловсруулагдсан.  3.  Мөр  бүрийн  урт  width-с хэтрэхгүй.
 16: Нотолгоо:  1.  Суурь  нөхцөл: Эхний үгээс өмнө ямар ч мөр үүсээгүй. 2.
 17: Хадгалалт:  Давталт  бүр дээр: - Хэрэв үг нь одоогийн мөрөнд багтахгүй
 18: бол  шинэ  мөр  эхэлнэ.  -  Үг  бүрийг  зөвхөн  нэг  удаа авч үзнэ. 3.
 19: Төгсгөл:  Бүх  үгс  боловсруулагдсан.  Алгоритм  зөв ажиллана. DYNAMIC
 20: PROGRAMMING  АЛГОРИТМЫН  ЗӨВ  БАЙДЛЫН  НОТОЛГОО:  1.  LOOP  INVARIANT:
 21: Өмнөх   нөхцөл:   minCost[i]  нь  i-р  үгнээс  эхлэн  төгсгөл  хүртэлх
 22: хамгийн  бага  зардлыг  агуулна.  Давталтын  invariant:  -  minCost[i]
 23: =  min(cost[i][j-1]  +  minCost[j]),  ∀  j  >  i  -  breakPoints[i] нь
 24: хамгийн  бага  зардалтай  таслах  цэг  2.  INDUCTION  НОТОЛГОО:  Суурь
 25: нөхцөл  (Base  Case):  i  =  n-1 үед: minCost[n-1] = 0 (зөв) Индукцийн
 26: алхам  (Inductive  Step):  i  <  k  ≤  n  үед  индукцийн  таамаглалаар
 27: minCost[k]  зөв  гэж  үзье. i-д зориулж: minCost[i] = min(cost[i][j-1]
 28: +  minCost[j]),  i  <  j  ≤ n Энэ нь Bellman-ийн оновчтой зарчим: "Дэд
 29: асуудлын  оновчтой  шийдлүүд  асуудлын  оновчтой шийдэлд агуулагдана."
 30: 3.  ТӨГСГӨЛИЙН  НӨХЦӨЛ  (Termination): Алгоритм i = 0 хүртэл ажиллана.
 31: minCost[0]   нь   бүх   бичвэрийн  хамгийн  бага  зардал.  breakPoints
 32: массив   ашиглан  оновчтой  таслалтыг  олно.  Алгоритм  зөв  ажиллана.
 33: ================================================================================
 34: НАРИЙН             ТӨВӨГТЭЙ             БАЙДЛЫН             ШИНЖИЛГЭЭ:
 35: ================================================================================
 36: GREEDY  АЛГОРИТМЫН  НАРИЙН  ТӨВӨГТЭЙ БАЙДАЛ: Цагийн нарийн төвөг: O(n)
 37: Хаана  n  = үгийн тоо Санах ойн нарийн төвөг: O(n) Хаана n = үгийн тоо
 38: Тайлбар:  -  Алгоритм нь үгс дээр нэг л удаа давталт хийдэг. - Мөр бүр
 39: дээр  аль  болох  олон  үг оруулдаг. - Hyphenation-ийн хувьд үг бүрийг
 40: шалгадаг.  DP  АЛГОРИТМЫН НАРИЙН ТӨВӨГТЭЙ БАЙДАЛ: Цагийн нарийн төвөг:
 41: O(n²)  Хаана  n  =  үгийн  тоо Санах ойн нарийн төвөг: O(n²) Хаана n =
 42: үгийн  тоо  Тайлбар:  1.  Зардлын  матриц  бөглөх: O(n²) 2. DP хүснэгт
 43: бөглөх:  O(n²)  3.  Үр  дүнг бүтээх: O(n) Дэд асуудлын тоо: n(n+1)/2 ≈
 44: O(n²)  Дэд асуудлын шийдлийг хадгалах: O(n²) DP нь Greedy-с илүү санах
 45: ой шаарддаг боловч илүү оновчтой үр дүн өгдөг.                        
